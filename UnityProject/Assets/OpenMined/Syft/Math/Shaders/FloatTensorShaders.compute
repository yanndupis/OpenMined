// 

struct Dimensions {
	int rows;
	int columns;
};

float sigmoid(float x)
{
    return 1 / (1 + exp(-x));
}

float derivative(float x) {
	return x * (1 - x);
}

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ScalarMultMain

RWStructuredBuffer<float> data;
RWStructuredBuffer<float> temp_scalar;
 
[numthreads(4,1,1)]
void ScalarMultMain (uint3 id : SV_DispatchThreadID) {
    data[id.x] = data[id.x] * temp_scalar[0];
}

#pragma kernel AbsMain

RWStructuredBuffer<float> abs_data;
 
[numthreads(1,1,1)]
void AbsMain (uint3 id : SV_DispatchThreadID) {
	if(abs_data[id.x] < 0) {
		abs_data[id.x] = -abs_data[id.x];
	}
}

#pragma kernel NegateValues

RWStructuredBuffer<float> data_neg;
RWStructuredBuffer<float> result_neg;
[numthreads(4,1,1)]
void NegateValues (uint3 id: SV_DispatchThreadID) {
	result_neg[id.x] = -data_neg[id.x];
}

#pragma kernel CeilValues

RWStructuredBuffer<float> data_ceil;
RWStructuredBuffer<float> result_ceil;
[numthreads(4,1,1)]
void CeilValues (uint3 id: SV_DispatchThreadID) {
		result_ceil[id.x] = ceil(data_ceil[id.x]);
}

#pragma kernel ElementwiseMultMain

RWStructuredBuffer<float> data_a;
RWStructuredBuffer<float> data_b;
RWStructuredBuffer<float> result;

[numthreads(4,1,1)]
void ElementwiseMultMain (uint3 id : SV_DispatchThreadID) {
    result[id.x] = data_a[id.x] * data_b[id.x];
}

#pragma kernel ElementwiseSubtractMain

RWStructuredBuffer<float> data_c;
RWStructuredBuffer<float> data_d;
RWStructuredBuffer<float> result;
[numthreads(4,1,1)]
void ElementwiseSubtractMain (uint3 id : SV_DispatchThreadID) {
    result[id.x] = data_c[id.x] - data_d[id.x];
}


#pragma kernel SigmoidMatrixMultiply

RWStructuredBuffer<float> data_e;
RWStructuredBuffer<float> data_f;
RWStructuredBuffer<float> data_g;
RWStructuredBuffer<Dimensions> dimensions_a;

[numthreads(4,1,1)]
void SigmoidMatrixMultiply (uint3 id : SV_DispatchThreadID) {
	float columns = dimensions_a[0].columns;

	float product = 0;

	for (int i = 0; i < columns; i++) {
		product += data_f[id.x * columns + i] * data_g[i];
	}

	data_e[id.x] = sigmoid(product);
}


#pragma kernel MultiplyDerivative

RWStructuredBuffer<float> data_h;
RWStructuredBuffer<float> data_i;

[numthreads(4,1,1)]
void MultiplyDerivative (uint3 id : SV_DispatchThreadID) {
	data_h[id.x] = data_h[id.x] * derivative(data_i[id.x]);
}


#pragma kernel AddMatrixMultiply

RWStructuredBuffer<float> data_j;
RWStructuredBuffer<float> data_k;
RWStructuredBuffer<float> data_l;
RWStructuredBuffer<Dimensions> dimensions_b;

[numthreads(4,1,1)]
void AddMatrixMultiply (uint3 id : SV_DispatchThreadID) {
	// transpose
	int columns = dimensions_b[0].rows;
	int rows = dimensions_b[0].columns;

	float product = 0;

	int t = 0;
	for (int i = 0; i < columns; i++) {
		product += data_k[id.x + t] * data_l[i];
		t += rows;
	}

	data_j[id.x] += product;
}

#pragma kernel Add_Main

RWStructuredBuffer<float> data_m;
RWStructuredBuffer<float> temp_adder;

[numthreads(4,1,1)]
void Add_Main (uint3 id: SV_DispatchThreadID) {
	data_m[id.x] = data_m[id.x] + temp_adder[0];
}



#pragma kernel ResetWeights

RWStructuredBuffer<float> weights;
RWStructuredBuffer<float> original_weights;

[numthreads(4,1,1)]
void ResetWeights (uint3 id : SV_DispatchThreadID) {
	weights[id.x] = original_weights[id.x];
}

#pragma kernel ZeroValues

RWStructuredBuffer<float> zeroData;

[numthreads(4,1,1)]
void ZeroValues (uint3 id: SV_DispatchThreadID) {
       zeroData[id.x] = 0;
}
